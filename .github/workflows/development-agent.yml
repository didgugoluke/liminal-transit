name: üöÄ Development Agent - Enhanced Story Implementation

on:
  workflow_dispatch:
    inputs:
      story_number:
        description: "Story issue number to implement"
        required: true
        type: string
      action:
        description: "Action to perform"
        required: true
        type: choice
        options:
          - "take_story"
          - "implement_tasks"
          - "complete_story"
        default: "take_story"

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

jobs:
  development-agent:
    runs-on: ubuntu-latest

    steps:
      - name: üöÄ Development Agent Initialization
        run: |
          echo "Enhanced Development Agent starting..."
          echo "Story: ${{ github.event.inputs.story_number }}"
          echo "Action: ${{ github.event.inputs.action }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: ‚ö° Setup Rate Limiting
        run: |
          echo "Setting up Development Agent environment with rate limiting..."
          chmod +x scripts/github-rate-limit-manager.sh

          # Check initial rate limits
          if ! scripts/github-rate-limit-manager.sh check; then
            echo "‚ùå Rate limits too low for Development Agent operations"
            scripts/github-rate-limit-manager.sh emergency "Development Agent"
            exit 1
          fi

          echo "‚úÖ Rate limits OK - proceeding with development tasks"
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}

      - name: ‚öôÔ∏è Configure Git and GitHub CLI
        run: |
          git config --global user.name "AI Development Agent"
          git config --global user.email "development-agent@noveli.sh"

          # Verify GitHub CLI authentication
          if ! gh auth status; then
            echo "‚ùå GitHub CLI authentication failed"
            exit 1
          fi

          echo "‚úÖ Git and GitHub CLI configured successfully"
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}

      - name: üè∑Ô∏è Ensure Required Labels
        run: |
          # Function to ensure a label exists, create if missing
          ensure_label_exists() {
            local label_name="$1"
            local label_color="${2:-0052CC}"  # Default blue
            local label_description="${3:-AI Agent Label}"
            
            if ! gh label list | grep -q "^$label_name"; then
              echo "üìù Creating missing label: $label_name"
              if gh label create "$label_name" --color "$label_color" --description "$label_description" 2>/dev/null; then
                echo "‚úÖ Created label: $label_name"
              else
                echo "‚ö†Ô∏è Failed to create label: $label_name (will use fallback)"
              fi
            else
              echo "‚úÖ Label exists: $label_name"
            fi
          }

          # Create agent-specific labels
          ensure_label_exists "ai-agent" "7B68EE" "Issues and PRs created by AI agents"
          ensure_label_exists "automated" "00D084" "Automated processes and workflows"
          ensure_label_exists "development" "1D76DB" "Development tasks and implementations"
          ensure_label_exists "database" "FF6B6B" "Database schema and configuration"
          ensure_label_exists "in-progress" "FFA500" "Story is currently being implemented"
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}

      - name: üìã Setup Enhanced Task Handlers
        run: |
          echo "üìã Setting up enhanced modular task handler system..."

          # Create enhanced task handler functions
          cat << 'HANDLERS_EOF' > task_handlers.sh
          #!/bin/bash

          # Enhanced Task Type Detection
          detect_task_type() {
            local TASK_TITLE="$1"
            local TASK_BODY="$2"
            
            case "$TASK_TITLE" in
              *"Database Schema"*|*"database"*|*"DB"*|*"schema"*)
                echo "database"
                ;;
              *"API"*|*"endpoint"*|*"REST"*|*"GraphQL"*|*"specification"*)
                echo "api"
                ;;
              *"UI"*|*"component"*|*"React"*|*"frontend"*|*"interface"*)
                echo "frontend"
                ;;
              *"Test"*|*"testing"*|*"spec"*|*"e2e"*)
                echo "testing"
                ;;
              *"Documentation"*|*"docs"*|*"README"*|*"guide"*)
                echo "documentation"
                ;;
              *"Infrastructure"*|*"terraform"*|*"AWS"*|*"deploy"*|*"cloud"*)
                echo "infrastructure"
                ;;
              *"Configuration"*|*"config"*|*"setup"*|*"environment"*)
                echo "configuration"
                ;;
              *)
                echo "generic"
                ;;
            esac
          }

          # Enhanced Database Schema Handler (Proven from v1)
          handle_database_task() {
            local TASK_NUM="$1"
            local TASK_TITLE="$2"
            local TASK_BODY="$3"
            
            echo "üóÑÔ∏è  Implementing Database Schema Design..."
            mkdir -p src/database
            
            # Create database schema (using printf for robust handling)
            printf '%s\n' \
              '-- NOVELI.SH Database Schema' \
              '-- AI Native Interactive Storytelling Platform' \
              '-- Generated by Enhanced Development Agent' \
              '' \
              '-- Core Tables for Story Management' \
              'CREATE TABLE stories (' \
              '    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),' \
              '    title VARCHAR(255) NOT NULL,' \
              '    description TEXT,' \
              '    content JSONB NOT NULL,' \
              '    status VARCHAR(50) DEFAULT '"'"'draft'"'"',' \
              '    created_at TIMESTAMP DEFAULT NOW(),' \
              '    updated_at TIMESTAMP DEFAULT NOW(),' \
              '    created_by VARCHAR(255),' \
              '    metadata JSONB DEFAULT '"'"'{}'"'"'' \
              ');' \
              '' \
              '-- User Sessions and Choices' \
              'CREATE TABLE user_sessions (' \
              '    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),' \
              '    session_id VARCHAR(255) UNIQUE NOT NULL,' \
              '    story_id UUID REFERENCES stories(id),' \
              '    current_scene VARCHAR(255),' \
              '    choices_made JSONB DEFAULT '"'"'[]'"'"',' \
              '    started_at TIMESTAMP DEFAULT NOW(),' \
              '    last_activity TIMESTAMP DEFAULT NOW()' \
              ');' \
              '' \
              '-- Indexes for Performance' \
              'CREATE INDEX idx_stories_status ON stories(status);' \
              'CREATE INDEX idx_user_sessions_session_id ON user_sessions(session_id);' \
              > src/database/schema.sql
            
            # Create TypeScript interfaces (using printf)
            printf '%s\n' \
              '// NOVELI.SH Database Types' \
              '// AI Native Interactive Storytelling Platform' \
              '// Generated by Enhanced Development Agent' \
              '' \
              'export interface Story {' \
              '  id: string;' \
              '  title: string;' \
              '  description?: string;' \
              '  content: StoryContent;' \
              '  status: '"'"'draft'"'"' | '"'"'published'"'"' | '"'"'archived'"'"';' \
              '  created_at: Date;' \
              '  updated_at: Date;' \
              '  created_by?: string;' \
              '  metadata: Record<string, any>;' \
              '}' \
              '' \
              'export interface StoryContent {' \
              '  scenes: Record<string, Scene>;' \
              '  startScene: string;' \
              '}' \
              '' \
              'export interface Scene {' \
              '  id: string;' \
              '  content: string;' \
              '  choices: Choice[];' \
              '}' \
              '' \
              'export interface Choice {' \
              '  text: string;' \
              '  target: string;' \
              '}' \
              > src/database/types.ts
            
            # Create database configuration (using printf)
            printf '%s\n' \
              '// NOVELI.SH Database Configuration' \
              '// AI Native Interactive Storytelling Platform' \
              '// Generated by Enhanced Development Agent' \
              '' \
              'export const databaseConfig = {' \
              '  development: {' \
              '    host: process.env.DB_HOST || '"'"'localhost'"'"',' \
              '    port: parseInt(process.env.DB_PORT || '"'"'5432'"'"'),' \
              '    database: process.env.DB_NAME || '"'"'noveli_dev'"'"',' \
              '  },' \
              '  production: {' \
              '    host: process.env.DB_HOST,' \
              '    port: parseInt(process.env.DB_PORT || '"'"'5432'"'"'),' \
              '    database: process.env.DB_NAME,' \
              '  }' \
              '};' \
              > src/database/config.ts

            echo "‚úÖ Database schema files created successfully"
            
            # Ensure TypeScript configuration exists for CI compliance
            if [ ! -f "tsconfig.json" ]; then
              echo "üìù Creating TypeScript configuration for CI compliance..."
              
              # Create main tsconfig.json
              printf '%s\n' \
                '{' \
                '  "compilerOptions": {' \
                '    "target": "ES2020",' \
                '    "useDefineForClassFields": true,' \
                '    "lib": ["ES2020", "DOM", "DOM.Iterable"],' \
                '    "types": ["node"],' \
                '    "module": "ESNext",' \
                '    "skipLibCheck": true,' \
                '    "moduleResolution": "bundler",' \
                '    "allowImportingTsExtensions": true,' \
                '    "resolveJsonModule": true,' \
                '    "isolatedModules": true,' \
                '    "noEmit": true,' \
                '    "jsx": "react-jsx",' \
                '    "strict": true,' \
                '    "noUnusedLocals": true,' \
                '    "noUnusedParameters": true,' \
                '    "noFallthroughCasesInSwitch": true' \
                '  },' \
                '  "include": ["src/**/*.ts", "src/**/*.tsx"]' \
                '}' \
                > tsconfig.json
              
              # Create tsconfig.node.json
              printf '%s\n' \
                '{' \
                '  "compilerOptions": {' \
                '    "composite": true,' \
                '    "skipLibCheck": true,' \
                '    "module": "ESNext",' \
                '    "moduleResolution": "bundler",' \
                '    "allowSyntheticDefaultImports": true,' \
                '    "strict": true,' \
                '    "types": ["node"]' \
                '  },' \
                '  "include": ["vite.config.ts"]' \
                '}' \
                > tsconfig.node.json
              
              # Ensure @types/node is in package.json
              if [ -f "package.json" ] && ! grep -q "@types/node" package.json; then
                echo "üì¶ Adding @types/node to package.json..."
                # This is a basic approach - in a real scenario, we'd use proper JSON manipulation
                if command -v jq >/dev/null 2>&1; then
                  jq '.devDependencies["@types/node"] = "^24.3.0"' package.json > package.json.tmp && mv package.json.tmp package.json
                fi
              fi
              
              echo "‚úÖ TypeScript configuration created for CI compliance"
            else
              echo "‚ÑπÔ∏è TypeScript configuration already exists"
            fi
            
            # Ensure ESLint configuration exists for CI compliance
            if [ ! -f ".eslintrc.js" ] && [ ! -f ".eslintrc.json" ] && ! grep -q '"eslintConfig"' package.json 2>/dev/null; then
              echo "üìù Creating basic ESLint configuration for CI compliance..."
              
              # Create minimal .eslintrc.json
              printf '%s\n' \
                '{' \
                '  "extends": [' \
                '    "@typescript-eslint/recommended"' \
                '  ],' \
                '  "parser": "@typescript-eslint/parser",' \
                '  "plugins": ["@typescript-eslint"],' \
                '  "parserOptions": {' \
                '    "ecmaVersion": "latest",' \
                '    "sourceType": "module"' \
                '  },' \
                '  "rules": {' \
                '    "@typescript-eslint/no-unused-vars": "warn",' \
                '    "@typescript-eslint/no-explicit-any": "warn"' \
                '  },' \
                '  "ignorePatterns": ["dist/", "node_modules/"]' \
                '}' \
                > .eslintrc.json
              
              echo "‚úÖ ESLint configuration created for CI compliance"
            else
              echo "‚ÑπÔ∏è ESLint configuration already exists"
            fi
            
            # Update task with completion
            gh issue comment "$TASK_NUM" --body "‚úÖ Enhanced Development Agent completed database schema design. Files created: schema.sql, types.ts, config.ts. Task ready for review."
            
            # Close the task
            gh issue close "$TASK_NUM" --reason completed
          }

          # Enhanced API Task Handler
          handle_api_task() {
            local TASK_NUM="$1"
            local TASK_TITLE="$2"
            local TASK_BODY="$3"
            
            echo "üîó Implementing API Design..."
            mkdir -p src/api/{routes,middleware,types}
            
            # Create API specification
            printf '%s\n' \
              '// NOVELI.SH API Specification' \
              '// AI Native Interactive Storytelling Platform' \
              '// Generated by Enhanced Development Agent' \
              '' \
              'export interface APIResponse<T = any> {' \
              '  success: boolean;' \
              '  data?: T;' \
              '  error?: string;' \
              '  timestamp: string;' \
              '}' \
              '' \
              'export interface StoryAPI {' \
              '  getStory: (id: string) => Promise<APIResponse<Story>>;' \
              '  createStory: (story: Partial<Story>) => Promise<APIResponse<Story>>;' \
              '  updateStory: (id: string, updates: Partial<Story>) => Promise<APIResponse<Story>>;' \
              '  deleteStory: (id: string) => Promise<APIResponse<void>>;' \
              '}' \
              > src/api/types/api.ts

            echo "‚úÖ API specification created successfully"
            
            gh issue comment "$TASK_NUM" --body "‚úÖ Enhanced Development Agent completed API design. API specification and types created. Task ready for review."
            gh issue close "$TASK_NUM" --reason completed
          }

          # Enhanced Frontend Task Handler
          handle_frontend_task() {
            local TASK_NUM="$1"
            local TASK_TITLE="$2"
            local TASK_BODY="$3"
            
            echo "üé® Implementing Frontend Component..."
            mkdir -p src/components/{ui,story,auth}
            
            # Create React component template
            printf '%s\n' \
              '// NOVELI.SH Frontend Component' \
              '// AI Native Interactive Storytelling Platform' \
              '// Generated by Enhanced Development Agent' \
              '' \
              'import React from '"'"'react'"'"';' \
              '' \
              'interface ComponentProps {' \
              '  // Define component props here' \
              '}' \
              '' \
              'export const Component: React.FC<ComponentProps> = () => {' \
              '  return (' \
              '    <div className="component">' \
              '      {/* Component implementation */}' \
              '    </div>' \
              '  );' \
              '};' \
              '' \
              'export default Component;' \
              > src/components/Component.tsx

            echo "‚úÖ Frontend component template created successfully"
            
            gh issue comment "$TASK_NUM" --body "‚úÖ Enhanced Development Agent completed frontend component design. React component template created. Task ready for review."
            gh issue close "$TASK_NUM" --reason completed
          }

          # Enhanced Generic Task Handler with Dynamic File Creation
          handle_generic_task() {
            local TASK_NUM="$1"
            local TASK_TITLE="$2"
            local TASK_BODY="$3"
            
            echo "üîß Processing generic task: $TASK_TITLE"
            
            # Extract file path from task requirements dynamically (handle backticks)
            FILE_PATH=$(echo "$TASK_BODY" | sed -n 's/.*Create[[:space:]]*`\([^`]*\)`.*/\1/p' | head -1)
            
            if [ -n "$FILE_PATH" ]; then
              echo "üìÅ Creating file: $FILE_PATH"
              
              # Create directory if needed
              mkdir -p "$(dirname "$FILE_PATH")"
              
              # Generate appropriate content based on file extension and task description
              case "$FILE_PATH" in
                *.ts|*.tsx)
                  echo "üîß Generating TypeScript file"
                  # Extract key requirements from task body
                  REQUIREMENTS=$(echo "$TASK_BODY" | grep -A 10 "### Requirements" | grep "^‚Ä¢" | sed 's/^‚Ä¢[[:space:]]*//' || echo "Basic implementation")
                  
                  printf '%s\n' \
                    "// NOVELI.SH - $TASK_TITLE" \
                    '// AI Native Interactive Storytelling Platform' \
                    '// Generated by Enhanced Development Agent' \
                    '' \
                    "// Task: $TASK_TITLE" \
                    "// Auto-generated based on task requirements" \
                    '' > "$FILE_PATH"
                  
                  # Add TypeScript content based on filename pattern
                  if [[ "$FILE_PATH" == *"config"* ]]; then
                    printf '%s\n' \
                      'export interface HelloConfig {' \
                      '  environment: string;' \
                      '  debug: boolean;' \
                      '  settings: Record<string, unknown>;' \
                      '}' \
                      '' \
                      'export const config: HelloConfig = {' \
                      '  environment: process.env.NODE_ENV || "development",' \
                      '  debug: process.env.DEBUG === "true",' \
                      '  settings: {}' \
                      '};' >> "$FILE_PATH"
                  elif [[ "$FILE_PATH" == *"hello"* || "$FILE_PATH" == *"index"* ]]; then
                    printf '%s\n' \
                      'export interface HelloWorldOptions {' \
                      '  message?: string;' \
                      '  timestamp?: boolean;' \
                      '}' \
                      '' \
                      'export class HelloWorld {' \
                      '  private options: HelloWorldOptions;' \
                      '' \
                      '  constructor(options: HelloWorldOptions = {}) {' \
                      '    this.options = { message: "Hello, World!", timestamp: true, ...options };' \
                      '  }' \
                      '' \
                      '  greet(): string {' \
                      '    const message = this.options.message || "Hello, World!";' \
                      '    return this.options.timestamp ? `${message} (${new Date().toISOString()})` : message;' \
                      '  }' \
                      '}' \
                      '' \
                      'export default HelloWorld;' >> "$FILE_PATH"
                  fi
                  ;;
                *.md)
                  echo "üìö Generating Markdown documentation"
                  printf '%s\n' \
                    "# $(basename "$FILE_PATH" .md | tr '[:lower:]' '[:upper:]' | tr '-' ' ')" \
                    '' \
                    "> AI Native Interactive Storytelling Platform Documentation" \
                    "> Generated by Enhanced Development Agent" \
                    '' \
                    '## Overview' \
                    '' \
                    "Documentation for $TASK_TITLE implementation." \
                    '' \
                    '## Installation' \
                    '' \
                    '```bash' \
                    'npm install' \
                    '```' \
                    '' \
                    '## Usage' \
                    '' \
                    '```typescript' \
                    'import { HelloWorld } from "./src/hello";' \
                    '' \
                    'const hello = new HelloWorld();' \
                    'console.log(hello.greet());' \
                    '```' \
                    '' \
                    '## API Documentation' \
                    '' \
                    'Auto-generated based on task requirements.' \
                    > "$FILE_PATH"
                  ;;
                *)
                  echo "üìÑ Creating generic file"
                  printf '%s\n' \
                    "# $TASK_TITLE" \
                    '' \
                    'Generated by Enhanced Development Agent' \
                    "Task requirements: $TASK_BODY" \
                    > "$FILE_PATH"
                  ;;
              esac
              
              echo "‚úÖ File created: $FILE_PATH"
            else
              echo "‚ö†Ô∏è No file path found in task requirements, creating generic implementation"
              # Fallback to generic implementation
              mkdir -p src/implementations
              printf '%s\n' \
                "// NOVELI.SH Implementation: $TASK_TITLE" \
                '// AI Native Interactive Storytelling Platform' \
                '// Generated by Enhanced Development Agent' \
                '' \
                "// Task: $TASK_TITLE" \
                "// Implementation details to be added" \
                > "src/implementations/$(echo "$TASK_TITLE" | tr ' ' '_' | tr '[:upper:]' '[:lower:]').ts"
            fi

            echo "‚úÖ Generic task implementation completed"
            
            gh issue comment "$TASK_NUM" --body "‚úÖ Enhanced Development Agent processed generic task. Files created based on task requirements. Task ready for review."
            gh issue close "$TASK_NUM" --reason completed
          }
          HANDLERS_EOF

          chmod +x task_handlers.sh
          echo "‚úÖ Enhanced task handlers configured"

      - name: üìä Story Context Analysis
        id: context_analysis
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
          STORY_NUMBER: ${{ github.event.inputs.story_number }}
        run: |
          echo "üîç Analyzing story context..."

          STORY_NUMBER="${{ github.event.inputs.story_number }}"

          # Validate inputs
          if [ -z "$STORY_NUMBER" ] || [ "$STORY_NUMBER" = "null" ]; then
            echo "‚ùå No story number provided"
            exit 1
          fi

          # Get story details
          STORY_TITLE=$(gh issue view "$STORY_NUMBER" --json title --jq '.title')
          STORY_BODY=$(gh issue view "$STORY_NUMBER" --json body --jq '.body')
          STORY_LABELS=$(gh issue view "$STORY_NUMBER" --json labels --jq '.labels[].name' | tr '\n' ',' | sed 's/,$//')

          echo "üìã Story: #$STORY_NUMBER - $STORY_TITLE"
          echo "üè∑Ô∏è Labels: $STORY_LABELS"

          # Set environment variables for subsequent steps (avoid large markdown content)
          echo "STORY_NUMBER=$STORY_NUMBER" >> $GITHUB_ENV
          echo "STORY_TITLE=$STORY_TITLE" >> $GITHUB_ENV
          echo "STORY_LABELS=$STORY_LABELS" >> $GITHUB_ENV

          # Save story body to file to avoid GitHub Actions parsing issues
          echo "$STORY_BODY" > /tmp/story_body.md

          # Export for step outputs (minimal data only)
          echo "story_number=$STORY_NUMBER" >> $GITHUB_OUTPUT
          echo "story_title=$STORY_TITLE" >> $GITHUB_OUTPUT
          echo "story_labels=$STORY_LABELS" >> $GITHUB_OUTPUT

      - name: üéØ Enhanced Development Execution
        id: execute
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
          STORY_NUMBER: ${{ env.STORY_NUMBER }}
          STORY_TITLE: ${{ env.STORY_TITLE }}
          STORY_LABELS: ${{ env.STORY_LABELS }}
        run: |
          echo "üöÄ Executing enhanced development workflow..."
          echo "Processing Story: #$STORY_NUMBER - $STORY_TITLE"

          # Set default action if not provided
          ACTION="${{ github.event.inputs.action }}"
          if [ -z "$ACTION" ] || [ "$ACTION" = "null" ]; then
            ACTION="take_story"
          fi
          echo "üéØ Action: $ACTION"

          # Source the task handlers
          source task_handlers.sh

          case "$ACTION" in
            "take_story")
              echo "üìù Taking ownership of story..."

              # Update story status to "In Progress"
              gh issue edit "$STORY_NUMBER" --add-label "in-progress"
              
              # Update project status from Todo to In Progress
              echo "üìã Moving story to In Progress status..."
              ITEM_ID=$(gh project item-list "2" --owner "didgugoluke" --format json | jq -r --arg title "$STORY_TITLE" '.items[] | select(.content.title == $title) | .id')
              
              if [ -n "$ITEM_ID" ] && [ "$ITEM_ID" != "null" ]; then
                echo "Found item ID: $ITEM_ID"
                if gh project item-edit --id "$ITEM_ID" --field-id "PVTSSF_lAHOCf5VHc4BB2AJzg0OtoQ" --single-select-option-id "47fc9ee4" --project-id "PVT_kwHOCf5VHc4BB2AJ"; then
                  echo "‚úÖ Story moved to In Progress status"
                else
                  echo "‚ö†Ô∏è Failed to update project status to In Progress"
                fi
              else
                echo "‚ö†Ô∏è Could not find item ID for story: $STORY_TITLE"
              fi
              
              # Create status comment using printf approach
              printf '%s\n' \
                'üöÄ **Enhanced Development Agent started**' \
                '' \
                'Story implementation beginning with enhanced modular task processing capabilities.' \
                '' \
                "**Story**: #$STORY_NUMBER - $STORY_TITLE" \
                '**Agent Version**: Enhanced (v1 proven core + v2 modular handlers)' \
                '**Status**: Taking ownership and analyzing tasks' \
                '' \
                'Will automatically progress through: take_story ‚Üí implement_tasks ‚Üí complete_story' \
                > /tmp/status_comment.md
              
              gh issue comment "$STORY_NUMBER" --body-file /tmp/status_comment.md
              rm /tmp/status_comment.md

              echo "next_action=implement_tasks" >> $GITHUB_OUTPUT
              ;;

            "implement_tasks")
              echo "üî® Implementing story tasks with enhanced modular system..."

              # Create feature branch with graceful conflict handling
              BRANCH_NAME="story/$STORY_NUMBER"
              
              # Fetch latest remote state to check for existing branches
              git fetch origin
              
              # Check if remote branch exists
              if git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
                echo "üîÑ Remote branch $BRANCH_NAME exists, cleaning up for fresh start..."
                
                # Delete remote branch to start clean
                git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "‚ÑπÔ∏è Remote branch delete completed"
                
                # Delete local branch if it exists
                git branch -D "$BRANCH_NAME" 2>/dev/null || echo "‚ÑπÔ∏è Local branch cleanup completed"
              fi
              
              # Create fresh branch from main
              git checkout main
              git pull origin main
              git checkout -b "$BRANCH_NAME"
              git push -u origin "$BRANCH_NAME"
              echo "‚úÖ Created fresh branch: $BRANCH_NAME"
              
              echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

              # Get linked tasks for this story (including closed tasks)
              TASK_NUMBERS=$(gh issue list --limit 100 --state all --json number,body,title | jq -r --arg story "#$STORY_NUMBER" '.[] | select(.body | contains($story)) | .number')

              if [ ! -z "$TASK_NUMBERS" ]; then
                echo "üìã Found linked tasks: $TASK_NUMBERS"
                
                for TASK_NUM in $TASK_NUMBERS; do
                  TASK_TITLE=$(gh issue view "$TASK_NUM" --json title --jq '.title')
                  TASK_BODY=$(gh issue view "$TASK_NUM" --json body --jq '.body')
                  
                  echo "üîß Processing Task #$TASK_NUM: $TASK_TITLE"
                  
                  # Enhanced modular task processing
                  TASK_TYPE=$(detect_task_type "$TASK_TITLE" "$TASK_BODY")
                  echo "üìã Detected task type: $TASK_TYPE"
                  
                  # DEBUG: Add comprehensive debugging before task execution
                  echo "üîç DEBUG: About to execute task handler for task type: $TASK_TYPE"
                  echo "üîç DEBUG: Current working directory: $(pwd)"
                  echo "üîç DEBUG: Task handler function exists?"
                  type handle_generic_task >/dev/null 2>&1 && echo "‚úÖ handle_generic_task function found" || echo "‚ùå handle_generic_task function NOT found"
                  
                  case "$TASK_TYPE" in
                    "database")
                      echo "üîç DEBUG: Calling handle_database_task..."
                      handle_database_task "$TASK_NUM" "$TASK_TITLE" "$TASK_BODY"
                      echo "üîç DEBUG: handle_database_task completed with exit code: $?"
                      ;;
                    "api")
                      echo "üîç DEBUG: Calling handle_api_task..."
                      handle_api_task "$TASK_NUM" "$TASK_TITLE" "$TASK_BODY"
                      echo "üîç DEBUG: handle_api_task completed with exit code: $?"
                      ;;
                    "frontend")
                      echo "üîç DEBUG: Calling handle_frontend_task..."
                      handle_frontend_task "$TASK_NUM" "$TASK_TITLE" "$TASK_BODY"
                      echo "üîç DEBUG: handle_frontend_task completed with exit code: $?"
                      ;;
                    "configuration"|"documentation"|*)
                      echo "üîç DEBUG: Calling handle_generic_task with params:"
                      echo "  TASK_NUM: $TASK_NUM"
                      echo "  TASK_TITLE: $TASK_TITLE"
                      echo "  TASK_BODY (first 100 chars): $(echo "$TASK_BODY" | head -c 100)..."
                      handle_generic_task "$TASK_NUM" "$TASK_TITLE" "$TASK_BODY"
                      HANDLER_EXIT_CODE=$?
                      echo "üîç DEBUG: handle_generic_task completed with exit code: $HANDLER_EXIT_CODE"
                      ;;
                  esac
                  
                  # DEBUG: Check file system after each task
                  echo "üîç DEBUG: After task processing, checking for created files:"
                  find . -name "*.ts" -o -name "*.md" | grep -E "(hello|config)" | head -5 | while read file; do
                    echo "  Found file: $file (size: $(wc -c < "$file" 2>/dev/null || echo "0") bytes)"
                  done
                done
                
                # COMPREHENSIVE DEBUG: Check what happened after all tasks
                echo "üîç DEBUG: All tasks processed, checking final state..."
                echo "üîç DEBUG: Current working directory: $(pwd)"
                echo "üîç DEBUG: All files in current directory:"
                ls -la
                echo "üîç DEBUG: Looking for hello/config files specifically:"
                find . -name "*hello*" -o -name "*config*" | grep -v node_modules | head -10
                echo "üîç DEBUG: Checking src directory structure:"
                find src/ -type f 2>/dev/null | head -10 || echo "src/ directory not found"
                echo "üîç DEBUG: Git status before commit check:"
                git status --porcelain
                echo "üîç DEBUG: Git diff check results:"
                if git diff --quiet; then
                  echo "  git diff --quiet: TRUE (no unstaged changes)"
                else
                  echo "  git diff --quiet: FALSE (unstaged changes found)"
                  git diff --name-only | head -5
                fi
                if git diff --staged --quiet; then
                  echo "  git diff --staged --quiet: TRUE (no staged changes)"
                else
                  echo "  git diff --staged --quiet: FALSE (staged changes found)"
                  git diff --staged --name-only | head -5
                fi
                # Check for any changes: modified files, staged files, OR untracked files
                HAS_CHANGES=false
                if ! git diff --quiet; then
                  echo "üîç Found unstaged changes"
                  HAS_CHANGES=true
                fi
                if ! git diff --staged --quiet; then
                  echo "üîç Found staged changes"
                  HAS_CHANGES=true
                fi
                if [ -n "$(git status --porcelain | grep '^??')" ]; then
                  echo "üîç Found untracked files"
                  git status --porcelain | grep '^??'
                  HAS_CHANGES=true
                fi
                
                if [ "$HAS_CHANGES" = "true" ]; then
                  echo "‚úÖ Changes detected, formatting and committing..."
                  
                  # Auto-format code files before committing
                  if [ -f "package.json" ] && grep -q '"prettier"' package.json; then
                    echo "üé® Auto-formatting code with Prettier..."
                    
                    # Ensure dependencies are installed
                    if command -v pnpm >/dev/null 2>&1; then
                      echo "üì¶ Installing dependencies with pnpm..."
                      pnpm install --silent
                      echo "üé® Running Prettier format..."
                      pnpm format || echo "‚ö†Ô∏è Prettier formatting failed, continuing..."
                    elif command -v npm >/dev/null 2>&1; then
                      echo "üì¶ Installing dependencies with npm..."
                      npm install --silent
                      echo "üé® Running Prettier format..."
                      npm run format || echo "‚ö†Ô∏è Prettier formatting failed, continuing..."
                    else
                      echo "‚ö†Ô∏è No package manager found, skipping formatting"
                    fi
                  else
                    echo "üìù No Prettier config found, skipping formatting"
                  fi
                  
                  # Re-check for changes after formatting (Prettier might have fixed everything)
                  git add .
                  
                  # Final check before commit
                  if git diff --staged --quiet; then
                    echo "‚ÑπÔ∏è No changes to commit after formatting - all files were already properly formatted"
                  else
                    echo "üìù Committing changes after formatting..."
                    git commit -m "üöÄ Enhanced Development Agent: Implement tasks for Story #$STORY_NUMBER - $(echo "$TASK_NUMBERS" | wc -w) tasks processed with modular handlers - $STORY_TITLE"
                    
                    # Push with conflict resolution
                    echo "üì§ Pushing changes to branch: $BRANCH_NAME"
                    if ! git push origin "$BRANCH_NAME"; then
                      echo "‚ö†Ô∏è Push failed, attempting to resolve conflicts..."
                      git pull origin "$BRANCH_NAME" --rebase || echo "‚ÑπÔ∏è No remote changes to rebase"
                      git push origin "$BRANCH_NAME"
                    fi
                    echo "‚úÖ All task implementations committed and pushed"
                  fi
                else
                  echo "‚ö†Ô∏è No changes to commit"
                fi
              else
                echo "‚ö†Ô∏è No linked tasks found for this story"
              fi

              echo "next_action=complete_story" >> $GITHUB_OUTPUT
              ;;

            "complete_story")
              echo "‚úÖ Completing story and creating PR..."

              BRANCH_NAME="story/$STORY_NUMBER"
              
              # Create comprehensive PR body using printf
              printf '%s\n' \
                '## üöÄ Enhanced Development Agent Implementation' \
                '' \
                "**Story**: #$STORY_NUMBER - $STORY_TITLE" \
                '' \
                '### üìã Implementation Summary' \
                'This PR implements the complete story using the Enhanced Development Agent with proven v1 core logic and enhanced v2 modular task processing capabilities.' \
                '' \
                '### ‚úÖ Implementation Checklist' \
                '- [x] Story analysis completed with enhanced context detection' \
                '- [x] Tasks implemented using modular specialized handlers' \
                '- [x] Files generated with improved structure and organization' \
                '- [x] Automated commit and PR creation with robust error handling' \
                '- [x] Project status synchronized with comprehensive tracking' \
                '' \
                '### üéØ Enhanced Features' \
                '- **Modular Task Processing**: Specialized handlers for database, API, frontend, and generic tasks' \
                '- **Improved File Generation**: Enhanced templates and structure' \
                '- **Better Error Handling**: Comprehensive validation and fallback mechanisms' \
                '- **Proven Core Logic**: Based on successful Story #54 implementation' \
                '' \
                '**Ready for review and merge** ‚úÖ' \
                > /tmp/pr_body.md

              # Create PR with enhanced robust label handling (proven from v1)
              echo "üìù Creating pull request..."

              # Create the PR first
              PR_URL=$(gh pr create \
                --title "üöÄ Enhanced Development Agent: Implement $STORY_TITLE (#$STORY_NUMBER)" \
                --body-file /tmp/pr_body.md \
                --head "$BRANCH_NAME" \
                --base main)
              
              rm /tmp/pr_body.md

              echo "‚úÖ Pull request created: $PR_URL"

              # Add appropriate labels based on task content
              echo "üìä Determining appropriate labels based on task content..."
              
              # Base labels for all Development Agent tasks
              base_labels="ai-agent automated development"
              
              # Context-specific labels based on file changes and task description
              context_labels=""
              
              # Check if this is a database infrastructure task (not just files in database folder)
              task_description=$(gh issue view "$STORY_NUMBER" --json body --jq '.body')
              if echo "$task_description" | grep -qi "database.*schema\|database.*design\|database.*infrastructure\|database.*migration\|sql.*schema"; then
                context_labels="$context_labels database"
                echo "üóÑÔ∏è Database infrastructure task detected, adding database label"
              else
                # Only check for new database files if this might be a database task
                # Don't add database label just because database files exist from previous work
                echo "ÔøΩ Hello World or non-database task - skipping database label even if database files exist"
              fi
              
              # Check if this is an enhancement (based on task description)
              if echo "$task_description" | grep -qi "enhance\|improvement\|optimize\|upgrade"; then
                context_labels="$context_labels enhanced"
                echo "‚ö° Enhancement detected, adding enhanced label"
              fi
              
              # Apply labels
              all_labels="$base_labels $context_labels"
              for label in $all_labels; do
                if gh label list | grep -q "^$label"; then
                  if gh pr edit "$PR_URL" --add-label "$label" 2>/dev/null; then
                    echo "‚úÖ Added label: $label"
                  else
                    echo "‚ö†Ô∏è Failed to add label: $label"
                  fi
                else
                  echo "‚ö†Ô∏è Label not found: $label"
                fi
              done

              # Extract PR number for Project Admin handoff
              PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
              echo "üîç Extracted PR number: $PR_NUMBER"
              
              # Update story status (but leave open for Project Admin to close)
              printf '%s\n' \
                "‚úÖ **Enhanced Development Agent completed Story #$STORY_NUMBER**" \
                '' \
                '**Implementation Summary:**' \
                '- ‚úÖ Enhanced modular task processing system implemented' \
                '- ‚úÖ All linked tasks completed with specialized handlers' \
                '- ‚úÖ Pull request created with comprehensive documentation' \
                '- ‚úÖ Ready for Project Admin Agent review and auto-merge' \
                '' \
                "**PR**: $PR_URL (#$PR_NUMBER)" \
                "**Branch**: $BRANCH_NAME" \
                '**Status**: Implementation complete, handing off to Project Admin Agent' \
                '' \
                'ü§ñ **Next Step**: Project Admin Agent will review, approve, and merge this PR automatically' \
                > /tmp/completion_comment.md
              
              gh issue comment "$STORY_NUMBER" --body-file /tmp/completion_comment.md
              rm /tmp/completion_comment.md

              # Store PR number for Project Admin handoff
              echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV
              echo "PR_URL=$PR_URL" >> $GITHUB_ENV
              
              echo "‚úÖ Development completed - ready for Project Admin review"
              ;;
          esac

      - name: üîÑ Auto-Progress to Next Phase
        if: steps.execute.outputs.next_action
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
          STORY_NUMBER: ${{ env.STORY_NUMBER }}
        run: |
          NEXT_ACTION="${{ steps.execute.outputs.next_action }}"

          echo "‚è≠Ô∏è  Auto-progressing to: $NEXT_ACTION"

          case "$NEXT_ACTION" in
            "implement_tasks")
              echo "üî® Starting enhanced task implementation..."
              sleep 10
              gh workflow run development-agent.yml \
                --field story_number="$STORY_NUMBER" \
                --field action="implement_tasks"
              ;;
            "complete_story")
              echo "‚úÖ Completing story with enhanced workflow..."
              sleep 10  
              gh workflow run development-agent.yml \
                --field story_number="$STORY_NUMBER" \
                --field action="complete_story"
              ;;
          esac

      - name: ü§ñ Project Admin Agent Handoff
        if: success() && env.PR_NUMBER != ''
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
          PR_NUMBER: ${{ env.PR_NUMBER }}
          PR_URL: ${{ env.PR_URL }}
          STORY_NUMBER: ${{ env.STORY_NUMBER }}
        run: |
          echo "üîÑ Handing off to Project Admin Agent..."
          echo "üìã PR: #$PR_NUMBER ($PR_URL)"
          echo "üìã Story: #$STORY_NUMBER"

          # Add small delay to ensure PR is fully created and labels are applied
          sleep 15

          echo "üöÄ Triggering Project Admin Agent for PR review and merge..."
          gh workflow run project-admin-agent.yml \
            --field pr_number="$PR_NUMBER" \
            --field action="review_and_merge"

          echo "‚úÖ Project Admin Agent triggered successfully"
          echo "üéØ Workflow complete - Project Admin will handle approval, merge, and story closure"

      - name: üö® Emergency Cleanup
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN }}
          STORY_NUMBER: ${{ env.STORY_NUMBER }}
        run: |
          echo "üö® Enhanced Development Agent execution failed - performing emergency cleanup..."

          # Clean up any partial work
          if [ ! -z "$STORY_NUMBER" ]; then
            if scripts/github-rate-limit-manager.sh check-rest "emergency comment" 5; then
              printf '%s\n' \
                'üö® **Enhanced Development Agent Failed**' \
                '' \
                'Agent execution encountered an error and has been stopped. Manual intervention may be required.' \
                '' \
                "**Story**: #$STORY_NUMBER" \
                "**Time**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
                '**Workflow**: Enhanced Development Agent' \
                "**Run**: ${{ github.run_id }}" \
                '' \
                'Please check the workflow logs for details.' \
                > /tmp/emergency_comment.md
                
              gh issue comment "$STORY_NUMBER" --body-file /tmp/emergency_comment.md
              rm /tmp/emergency_comment.md
            fi
          fi
